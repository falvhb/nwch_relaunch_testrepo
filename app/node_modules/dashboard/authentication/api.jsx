import { pick } from 'lodash/object';
import axios from 'axios';

const LOGIN_URL = '/__api/v1/login';
const REGISTER_URL = '/__api/v1/registration';

// Place for translating
function translateMessage(message) {
  return {
    unknown: 'Something went wrong but we don\'t know what'
  }[message.toLowerCase()] || message;
};

function errorMessage(message) {
  return {
    errorMessage: message || translateMessage('unknown'),
    submitting: false
  }
}

export default {
  login(data, callback) {
    var fieldsToPost = pick(data, ['email', 'password']);

    axios.post(LOGIN_URL, fieldsToPost).then(function(response) {
      var data = response.data;
      if (data.error) {
        callback({
          errorMessage: translateMessage(data.error),
          submitting: false
        })
      } else if (data.status === "ok") {
        callback({
          authenticated: true,
          submitting: false
        })
      } else {
        callback(errorMessage());
      }
    }).catch( () => callback(errorMessage()) );
  },
  register(data, callback) {
    var fieldsToPost = pick(data, [
      'username',
      'email',
      'password'
    ]);

    if (data.password !== data.password_confirmation) {
      callback(errorMessage('Passwords don\'t match'));
      return
    }

    axios.post(REGISTER_URL, fieldsToPost).then(function(response) {
      var data = response.data;
      if (data.errors) {
        callback({
          errorMessage: data.errors.map(translateMessage),
          submitting: false
        })
      } else if (data.status === "ok") {
        // We don't want to mark the user as authenticated yet,
        // because this should be set only when there's a login cookie.
        // People still need to verify email, so we go to login+message instead
        callback({
          authenticated: false,
          type: 'login',
          errorMessage: errorMessage('verify email address'),
          submitting: false
        })
      } else {
        callback(errorMessage());
      }
    }).catch( () => callback(errorMessage()) );
  }
}
