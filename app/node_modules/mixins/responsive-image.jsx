/*eslint-disable no-console */
'use strict';

const CryptoJS = require('crypto-js');
const path = require('path');
const isRetina = require('is-retina');

const IMAGE_SALT = 'FyfgR5fadpR7S9w';

var viewportWidth = 0;
var screenFactor = 320;

// Requested sizes i.e. <ResponsiveImage size="small" />
var sizes = {
  micro: 80,
  tiny: 160,
  small: 320,
  medium: 640,
  large: 960,
  huge: 1280,
  full: 1600,
  wide: 1920
};

// Screen size -> size mapping
var screens = {
  // 0 -> 320
  tiny: {
    micro: 'micro',
    tiny: 'tiny', small: 'tiny', medium: 'tiny',
    large: 'small', huge: 'small', full: 'small'
  },
  // 320 -> 640
  small: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small', medium: 'small',
    large: 'medium', huge: 'medium', full: 'medium'
  },
  // 640 -> 960
  medium: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small',
    medium: 'medium',
    large: 'large', huge: 'large', full: 'large'
  },
  // 960 -> 1280
  large: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small',
    medium: 'medium',
    large: 'large',
    huge: 'huge', full: 'huge'
  },
  // 1280 -> 1600
  huge: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small',
    medium: 'medium',
    large: 'huge',
    huge: 'full', full: 'full'
  },
  // 1600+
  wide: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small',
    medium: 'medium',
    large: 'huge',
    huge: 'wide', full: 'wide'
  }
};

// No JS/ no <picture> fallback
var fallback = 'medium';

// Retina images up to
var retinaMax = 1280;

const ResponsiveImageMixin = {

  urlEncode(str) {
    return str.replace(/\=$/, '').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
  },

  createImageSignature(width, height) {
    var size = '/'.concat(width, 'x', height);
    var signature = CryptoJS.HmacSHA1(size, IMAGE_SALT);
    var encodedSignature = this.urlEncode(CryptoJS.enc.Base64.stringify(signature));
    return path.join(encodedSignature, size);
  },

  createImageSrc(src, width, height) {
    return src + '/' + this.createImageSignature(width, height);
  },

  getScreenSize() {
    var screenSizes = Object.keys(screens);
    // No JS / server.js
    if (!this.state.responsiveImagesSupported) {
      return fallback;
    }
    // Responsive Image
    viewportWidth = viewportWidth || Math.max(document.documentElement.clientWidth, window.innerWidth) || screenFactor;
    var current = Math.min(Math.ceil(viewportWidth/screenFactor) - 1, screenSizes.length - 1);
    return screenSizes[current];
  },

  sizeOrFallback(size) {
    if (!sizes[size]) {
      console.warn('ResponsiveImage size "' + size + '" not found, using fallback');
      // Return default
      return fallback;
    }
    return size;
  },

  getImageVariation(size) {
    return screens[this.getScreenSize()][this.sizeOrFallback(size)];
  },

  imageDimensionsForSize(size, ratio) {
    var imageRatio = ratio || '16x9';
    var imageWidth = sizes[size];
    var factors = imageRatio.split('x');
    return {
      width: imageWidth,
      height: Math.ceil((factors[1] / factors[0]) * imageWidth)
    };
  },

  responsiveImageSrc(src, size, ratio) {
    var dimensions = this.imageDimensionsForSize(this.getImageVariation(size), ratio);
    // Double output size on retina (but not the largest images)
    if (isRetina() && this.state.responsiveImagesSupported && dimensions.width <= retinaMax) {
      dimensions.width = dimensions.width * 2;
      dimensions.height = dimensions.height * 2;
    }
    return this.createImageSrc(src, dimensions.width, dimensions.height);
  }
};

module.exports = ResponsiveImageMixin;
