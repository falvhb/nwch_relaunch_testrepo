/*eslint-disable no-console */

import CryptoHMAC from 'crypto-js/hmac-sha1';
import CryptoBase64 from 'crypto-js/enc-base64';
import path from 'path';
import isRetina from 'is-retina';
import { fitImageToBox } from 'helpers';

// Requested sizes i.e. <ResponsiveImage size="small" />
const sizes = {
  tiny: 100,
  xsmall: 200,
  small: 300,
  regular: 350,
  medium: 450,
  large: 580,
  xlarge: 720,
  max: 900
};

// Configuration
const imageSalt = process.env.GOLDBACH_SALT || 'FyfgR5fadpR7S9w';
const screenBase = 200;
const screenFactor = 150;
const defaultRatio = '16x9';
const fallbackSize = 'medium';
const retinaMax = sizes.huge;

var viewportWidth = 0;

// Screen size -> image size mapping
const screens = {
  // 200 - 350
  tiny: {
    'tiny': 'tiny',
    'small': 'medium',
    'medium': 'small',
    'large': 'small',
    'full': 350
  },
  // 350 - 500
  xsmall: {
    'tiny': 'tiny',
    'small': 'medium',
    'medium': 'regular',
    'large': 'medium',
    'full': 500
  },
  // 500 - 650
  small: {
    'tiny': 'tiny',
    'small': 'small',
    'medium': 'medium',
    'large': 'large',
    'full': 650
  },
  // 650 -> 800
  medium: {
    'tiny': 'tiny',
    'small': 'regular',
    'medium': 'medium',
    'large': 'xlarge',
    'full': 800
  },
  // 800 -> 950
  large: {
    'tiny': 'tiny',
    'small': 'small',
    'medium': 'large',
    'large': 'large',
    'full': 900
  },
  // 950 -> 1100
  xlarge: {
    'tiny': 'tiny',
    'small': 'regular',
    'medium': 'large',
    'large': 'xlarge',
    'full': 900
  },
  // 1100+
  xxlarge: {
    'tiny': 'tiny',
    'small': 'regular',
    'medium': 'large',
    'large': 'xlarge',
    'full': 900
  }
};


export default {

  base64Encode(str) {
    return str.replace(/\=$/, '').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
  },

  createImageSignature(params) {
    if (params.salt) {
      var size = '/'.concat(params.width, 'x', params.height, (params.letterbox ? ',fill' : ''), (params.fill ? ',ar' : ''));
      var signature = CryptoHMAC(size, params.salt);
      var encodedSignature = this.base64Encode(CryptoBase64.stringify(signature));
      return path.join(encodedSignature, size);
    }
  },

  createImageSrc(params) {
    return params.src + '/' + this.createImageSignature({
      width: params.width,
      height: params.height,
      letterbox: params.letterbox,
      salt: imageSalt
    });
  },

  getViewportWidth() {
    return viewportWidth || Math.max(document.documentElement.clientWidth, window.innerWidth) || screenFactor;
  },

  getScreenSize() {
    var screenSizes = Object.keys(screens);
    // No JS / server.js
    if (!this.state.support) {
      return screenSizes[screenSizes.length - 1];
    }
    // Responsive Image
    var viewport = this.state.maxViewport || this.getViewportWidth();
    var current = Math.min(Math.ceil(viewport/(screenBase + screenFactor)) - 1, screenSizes.length - 1);

    return screenSizes[current];
  },

  sizeOrFallback(size) {
    if (!sizes[size]) {
      console.warn('ResponsiveImage size "' + size + '" not found, using fallback "' + fallbackSize + '"');
      return fallbackSize;
    }
    return size;
  },

  getImageVariation(size) {
    return screens[this.getScreenSize()][this.sizeOrFallback(size)];
  },

  imageDimensionsForSize(size, ratio) {
    var imageRatio = ratio || defaultRatio;
    var factors = imageRatio.split('x');
    var imageWidth = parseInt(sizes[size]);
    var widthFactor = parseInt(factors[0]);
    var heightFactor = parseInt(factors[1]);
    return {
      width: imageWidth,
      height: Math.ceil((heightFactor / widthFactor) * imageWidth)
    };
  },

  responsiveImageSrc(params) {
    var dimensions = this.imageDimensionsForSize(this.getImageVariation(params.size), params.ratio);
    // Double output size on retina (but not the largest images)
    if (isRetina() && this.state.support && dimensions.width <= retinaMax) {
      dimensions.width *= 2;
      dimensions.height *= 2;
    }

    return this.createImageSrc({
      src: params.src,
      width: dimensions.width,
      height: dimensions.height,
      letterbox: params.letterbox
    });
  },

  getImg() {
    return this.refs.img.getDOMNode();
  },

  removeLoadingListeners() {
    this.getImg().removeEventListener('load', this.hasLoaded);
    this.getImg().removeEventListener('error', this.hasErrored);
  },

  hasFailed() {
    this.removeLoadingListeners();
    this.getDOMNode().parentElement.classList.add('is-failed');
    this.setState({
      failed: true,
      loading: false
    });
  },

  hasLoaded() {
    this.removeLoadingListeners();
    this.setState({
      loading: false,
      maxViewport: this.getViewportWidth(),
      src: this.responsiveImageSrc({
        src: this.props.src,
        size: this.props.size,
        ratio: this.props.ratio,
        letterbox: this.props.letterbox
      })
    });

    if (this.props.fill) fitImageToBox(this.getDOMNode());
  },

  lazyLoadSrc() {
    var src = this.getImg().getAttribute('data-src');
    this.setState({ src: src });
  },

  testLoaded() {
    if (this.state.loading && this.state.support) {
      this.getImg().addEventListener('load', this.hasLoaded);
      this.getImg().addEventListener('error', this.hasFailed);
    }
  },

  handleResize() {
    var newWidth = this.getViewportWidth();
    // Only request a new image if we enlarge the viewport
    // Update the maximum viewport size and current src
    if (newWidth > this.state.maxViewport) {
      this.setState({
        maxViewport: newWidth,
        src: this.responsiveImageSrc({
          src: this.props.src,
          size: this.props.size,
          ratio: this.props.ratio,
          letterbox: this.props.letterbox
        })
      });
    }

    if (this.props.fill) fitImageToBox(this.getDOMNode());
  }

};
