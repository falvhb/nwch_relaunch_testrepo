/*eslint-disable no-console */

import _ from 'lodash';
import CryptoHMAC from 'crypto-js/hmac-sha1';
import CryptoBase64 from 'crypto-js/enc-base64';
import path from 'path';
import isRetina from 'is-retina';
import { fitImageToBox } from 'helpers';

import imageConfig from 'config/images';

// Configuration
const imageSalt = process.env.GOLDBACH_SALT || 'FyfgR5fadpR7S9w';
const minWidth = 320;
const defaultRatio = '16x9';
const retinaMax = imageConfig.standardImageSizes.full;

export default {

  fallbackType: 'medium',

  viewportTypeForWidth(w) {
    let viewportType;
    _.find(imageConfig.screenTypes, function(n, key) {
      var start = n[0], end = n[1];
      if (viewportType) return;
      if (end && _.inRange(w, start, end) || !end && w > start) viewportType = key;
    });
    return viewportType || Object.keys(imageConfig.screenTypes)[0];
  },

  base64Encode(str) {
    return str.replace(/\=$/, '').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
  },

  createImageSignature(params) {
    if (params.salt) {
      var size = '/'.concat(params.width, 'x', params.height, (params.letterbox ? ',fill' : ''), (params.fill ? ',ar' : ''));
      var signature = CryptoHMAC(size, params.salt);
      var encodedSignature = this.base64Encode(CryptoBase64.stringify(signature));
      return path.join(encodedSignature, size);
    }
  },

  createImageSrc(params) {
    return params.src + '/' + this.createImageSignature({
      width: params.width,
      height: params.height,
      letterbox: params.letterbox,
      salt: imageSalt
    });
  },

  getViewportWidth() {
    return Math.max(document.documentElement.clientWidth, window.innerWidth) || minWidth;
  },

  imageWidthFromSizeVariation(variation, componentMounted) {
    let fallback = imageConfig.standardImageSizes[this.fallbackType];

    if (!componentMounted) {
      return fallback;
    }

    if (!imageConfig.imageVariations[variation]) {
      console.warn('ResponsiveImage size "' + variation + '" not found, using fallback "' + this.fallbackType + '"');
      return fallback;
    }

    let viewport = this.viewportTypeForWidth(this.getViewportWidth());
    let imageSize = imageConfig.imageVariations[variation][viewport];

    if (!imageSize) {
      console.warn('ResponsiveImage variation "' + viewport + '" not found for "' + variation + '" size, using fallback "' + this.fallbackType + '"');
      return fallback;
    }

    return (isNaN(imageSize) ? imageConfig.standardImageSizes[imageSize] : imageSize) || fallback;
  },

  imageDimensionsForParams(size, ratio) {
    var imageRatio = ratio || defaultRatio;
    var factors = imageRatio.split('x');
    factors = factors.length < 2 ? defaultRatio.split('x') : factors;
    var imageWidth = parseInt(size);
    var widthFactor = parseInt(factors[0]);
    var heightFactor = parseInt(factors[1]);
    return {
      width: imageWidth,
      height: Math.ceil((heightFactor / widthFactor) * imageWidth)
    };
  },

  responsiveImageSrc(params) {
    var componentMounted = this.state.support;
    var imageWidth = this.imageWidthFromSizeVariation(params.size, componentMounted);
    var dimensions = this.imageDimensionsForParams(imageWidth, params.ratio);

    // Double output size on retina (but not the largest images)
    if (isRetina() && this.state.support && dimensions.width <= retinaMax) {
      dimensions.width *= 2;
      dimensions.height *= 2;
    }

    return this.createImageSrc({
      src: params.src,
      width: dimensions.width,
      height: dimensions.height,
      letterbox: params.letterbox
    });
  },

  getImg() {
    return this.refs.img.getDOMNode();
  },

  removeLoadingListeners() {
    this.getImg().removeEventListener('load', this.hasLoaded);
    this.getImg().removeEventListener('error', this.hasErrored);
  },

  hasFailed() {
    this.removeLoadingListeners();
    this.getDOMNode().parentElement.classList.add('is-failed');
    this.setState({
      failed: true,
      loading: false
    });
  },

  hasLoaded() {
    this.removeLoadingListeners();
    this.setState({
      loading: false,
      maxViewport: this.getViewportWidth(),
      src: this.responsiveImageSrc({
        src: this.props.src,
        size: this.props.size,
        ratio: this.props.ratio,
        letterbox: this.props.letterbox
      })
    });

    if (this.props.fitToBox) fitImageToBox(this.getDOMNode());
  },

  lazyLoadSrc() {
    var src = this.getImg().getAttribute('data-src');
    this.setState({ src: src });
  },

  testLoaded() {
    if (this.state.loading && this.state.support) {
      this.getImg().addEventListener('load', this.hasLoaded);
      this.getImg().addEventListener('error', this.hasFailed);
    }
  },

  handleResize() {
    var newWidth = this.getViewportWidth();
    // Only request a new image if we enlarge the viewport
    // Update the maximum viewport size and current src
    if (newWidth > this.state.maxViewport) {
      this.setState({
        maxViewport: newWidth,
        src: this.responsiveImageSrc({
          src: this.props.src,
          size: this.props.size,
          ratio: this.props.ratio,
          letterbox: this.props.letterbox
        })
      });
    }

    if (this.props.fitToBox) fitImageToBox(this.getDOMNode());
  }

};

/*eslint-enable no-console */
