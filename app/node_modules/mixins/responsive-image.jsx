/*eslint-disable no-console */
'use strict';

const CryptoJS = require('crypto-js');
const path = require('path');
const isRetina = require('is-retina')();

// Requested sizes i.e. <ResponsiveImage size="small" />
const sizes = {
  micro: 80,
  tiny: 160,
  small: 320,
  medium: 640,
  large: 960,
  huge: 1280,
  full: 1600,
  wide: 1920
};

// Configuration
const imageSalt = 'FyfgR5fadpR7S9w';
const screenFactor = 320;
const defaultRatio= '3x2';
const fallback = 'medium';
const retinaMax = sizes.huge;

var viewportWidth = 0;

// Screen size -> image size mapping
const screens = {
  // 0 -> 320
  tiny: {
    micro: 'micro',
    tiny: 'tiny', small: 'tiny', medium: 'tiny',
    large: 'small', huge: 'small', full: 'small'
  },
  // 320 -> 640
  small: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small', medium: 'small',
    large: 'medium', huge: 'medium', full: 'medium'
  },
  // 640 -> 960
  medium: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small',
    medium: 'medium',
    large: 'large', huge: 'large', full: 'large'
  },
  // 960 -> 1280
  large: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small',
    medium: 'medium',
    large: 'large',
    huge: 'huge', full: 'huge'
  },
  // 1280 -> 1600
  huge: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small',
    medium: 'medium',
    large: 'huge',
    huge: 'full', full: 'full'
  },
  // 1600+
  wide: {
    micro: 'micro',
    tiny: 'tiny',
    small: 'small',
    medium: 'medium',
    large: 'huge',
    huge: 'wide', full: 'wide'
  }
};


const ResponsiveImageMixin = {

  urlEncode(str) {
    return str.replace(/\=$/, '').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
  },

  createImageSignature(width, height) {
    var size = '/'.concat(width, 'x', height);
    var signature = CryptoJS.HmacSHA1(size, imageSalt);
    var encodedSignature = this.urlEncode(CryptoJS.enc.Base64.stringify(signature));
    return path.join(encodedSignature, size);
  },

  createImageSrc(params) {
    return params.src + '/' + this.createImageSignature(params.width, params.height);
  },

  getViewportWidth() {
    return viewportWidth || Math.max(document.documentElement.clientWidth, window.innerWidth) || screenFactor;
  },

  getScreenSize() {
    var screenSizes = Object.keys(screens);
    // No JS / server.js
    if ( ! this.state.support) {
      return fallback;
    }
    // Responsive Image
    var viewport = this.state.maxViewport || this.getViewportWidth();
    var current = Math.min(Math.ceil(viewport/screenFactor) - 1, screenSizes.length - 1);
    return screenSizes[current];
  },

  sizeOrFallback(size) {
    if ( ! sizes[size]) {
      console.warn('ResponsiveImage size "' + size + '" not found, using fallback');
      return fallback;
    }
    return size;
  },

  getImageVariation(size) {
    return screens[this.getScreenSize()][this.sizeOrFallback(size)];
  },

  imageDimensionsForSize(size, ratio) {
    var imageRatio = ratio || defaultRatio;
    var imageWidth = sizes[size];
    var factors = imageRatio.split('x');
    return {
      width: imageWidth,
      height: Math.ceil((factors[1] / factors[0]) * imageWidth)
    };
  },

  responsiveImageSrc(params) {
    var dimensions = this.imageDimensionsForSize(this.getImageVariation(params.size), params.ratio);
    // Double output size on retina (but not the largest images)
    if (isRetina && this.state.support && dimensions.width <= retinaMax) {
      dimensions.width *= 2;
      dimensions.height *= 2;
    }

    return this.createImageSrc({
      src: params.src,
      width: dimensions.width,
      height: dimensions.height
    });
  },

  getImg() {
    return this.refs.img.getDOMNode();
  },

  hasLoaded() {
    this.setState({
      loading: false,
      maxViewport: this.getViewportWidth(),
      src: this.responsiveImageSrc({ src: this.props.src, size: this.props.size, ratio: this.props.ratio })
    });
    this.getImg().removeEventListener('load', this.hasLoaded);
  },

  lazyLoadSrc() {
    var src = this.getImg().getAttribute('data-src');
    this.setState({ src: src });
  },

  testLoaded() {
    if (this.state.loading && this.state.support) {
      this.getImg().addEventListener('load', this.hasLoaded);
    }
  },

  handleResize() {
    var newWidth = this.getViewportWidth();
    // Only request a new image if we enlarge the viewport
    // Update the maximum viewport size and current src
    if (newWidth > this.state.maxViewport) {
      this.setState({
        maxViewport: newWidth,
        src: this.responsiveImageSrc({
          src: this.props.src,
          size: this.props.size,
          ratio: this.props.ratio
        })
      });
    }
  }

};

module.exports = ResponsiveImageMixin;
