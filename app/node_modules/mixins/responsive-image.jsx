/*eslint-disable no-console */

import CryptoHMAC from 'crypto-js/hmac-sha1';
import CryptoBase64 from 'crypto-js/enc-base64';
import path from 'path';
import isRetina from 'is-retina';

// Requested sizes i.e. <ResponsiveImage size="small" />
const sizes = {
  tiny: 90,
  narrow: 180,
  small: 320,
  medium: 480,
  large: 650,
  max: 850
};

// Configuration
const imageSalt = process.env.GOLDBACH_SALT || 'FyfgR5fadpR7S9w';
const screenFactor = 320;
const defaultRatio= '16x9';
const fallbackSize = 'medium';
const retinaMax = sizes.huge;

var viewportWidth = 0;

// Screen size -> image size mapping
const screens = {
  // 0 -> 320
  tiny: {
    'tiny': 'tiny',
    'narrow': 'tiny',
    'small': 'small',
    'medium': 'small',
    'large': 'small',
    'max': 'small'
  },
  // 320 -> 640
  small: {
    'tiny': 'tiny',
    'narrow': 'narrow',
    'small': 'medium',
    'medium': 'large',
    'large': 'large',
    'max': 'large'
  },
  // 640 -> 960
  medium: {
    'tiny': 'tiny',
    'narrow': 'small',
    'small': 'medium',
    'medium': 'medium',
    'large': 'large',
    'max': 'max'
  }
};


export default {

  base64Encode(str) {
    return str.replace(/\=$/, '').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
  },

  createImageSignature(params) {
    if (params.salt) {
      var size = '/'.concat(params.width, 'x', params.height, (params.letterbox ? ',fill' : ''));
      var signature = CryptoHMAC(size, params.salt);
      var encodedSignature = this.base64Encode(CryptoBase64.stringify(signature));
      return path.join(encodedSignature, size);
    }
  },

  createImageSrc(params) {
    return params.src + '/' + this.createImageSignature({
      width: params.width,
      height: params.height,
      letterbox: params.letterbox,
      salt: imageSalt
    });
  },

  getViewportWidth() {
    return viewportWidth || Math.max(document.documentElement.clientWidth, window.innerWidth) || screenFactor;
  },

  getScreenSize() {
    var screenSizes = Object.keys(screens);
    // No JS / server.js
    if (!this.state.support) {
      return screenSizes[screenSizes.length - 1];
    }
    // Responsive Image
    var viewport = this.state.maxViewport || this.getViewportWidth();
    var current = Math.min(Math.ceil(viewport/screenFactor) - 1, screenSizes.length - 1);
    return screenSizes[current];
  },

  sizeOrFallback(size) {
    if (!sizes[size]) {
      console.warn('ResponsiveImage size "' + size + '" not found, using fallback "' + fallbackSize + '"');
      return fallbackSize;
    }
    return size;
  },

  getImageVariation(size) {
    return screens[this.getScreenSize()][this.sizeOrFallback(size)];
  },

  imageDimensionsForSize(size, ratio) {
    var imageRatio = ratio || defaultRatio;
    var factors = imageRatio.split('x');
    var imageWidth = parseInt(sizes[size]);
    var widthFactor = parseInt(factors[0]);
    var heightFactor = parseInt(factors[1]);
    return {
      width: imageWidth,
      height: Math.ceil((heightFactor / widthFactor) * imageWidth)
    };
  },

  responsiveImageSrc(params) {
    var dimensions = this.imageDimensionsForSize(this.getImageVariation(params.size), params.ratio);
    // Double output size on retina (but not the largest images)
    if (isRetina() && this.state.support && dimensions.width <= retinaMax) {
      dimensions.width *= 2;
      dimensions.height *= 2;
    }

    return this.createImageSrc({
      src: params.src,
      width: dimensions.width,
      height: dimensions.height,
      letterbox: params.letterbox
    });
  },

  getImg() {
    return this.refs.img.getDOMNode();
  },

  removeLoadingListeners() {
    this.getImg().removeEventListener('load', this.hasLoaded);
    this.getImg().removeEventListener('error', this.hasErrored);
  },

  hasFailed() {
    this.removeLoadingListeners();
    this.getDOMNode().parentElement.classList.add('is-failed');
    this.setState({
      failed: true,
      loading: false
    });
  },

  fitToBox() {
    const wrapper = this.getDOMNode();
    const img = wrapper.querySelector('img');
    const wrapperDims = wrapper.getBoundingClientRect();
    const imgDims = img.getBoundingClientRect();
    if (wrapperDims.width > imgDims.width && imgDims.width > imgDims.height) {
      let percentageLarger = (wrapperDims.width / imgDims.width * 100);
      img.style.width = percentageLarger + '%';
    }
  },

  hasLoaded() {
    this.removeLoadingListeners();
    this.setState({
      loading: false,
      maxViewport: this.getViewportWidth(),
      src: this.responsiveImageSrc({
        src: this.props.src,
        size: this.props.size,
        ratio: this.props.ratio,
        letterbox: this.props.letterbox
      })
    });
    this.fitToBox(this.props.fill);
  },

  lazyLoadSrc() {
    var src = this.getImg().getAttribute('data-src');
    this.setState({ src: src });
  },

  testLoaded() {
    if (this.state.loading && this.state.support) {
      this.getImg().addEventListener('load', this.hasLoaded);
      this.getImg().addEventListener('error', this.hasFailed);
    }
  },

  handleResize() {
    var newWidth = this.getViewportWidth();
    // Only request a new image if we enlarge the viewport
    // Update the maximum viewport size and current src
    if (newWidth > this.state.maxViewport) {
      this.setState({
        maxViewport: newWidth,
        src: this.responsiveImageSrc({
          src: this.props.src,
          size: this.props.size,
          ratio: this.props.ratio,
          letterbox: this.props.letterbox
        })
      });
    }
  }

};
