import jQuery from 'jquery';
import Tracking from 'mixins/tracking';

export default {

  isMobile() {
    // check user agent to determine if we are on a mobile browser
    return ( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) );
  },

  defineIsOnScreen() {
    // define jQuery plugin used for checking if an DOM node is on screen
    jQuery.fn.isOnScreen = function() {
      var win = jQuery(window);
      var bounds, viewport;

      viewport = {
        top: win.scrollTop(),
        left: win.scrollLeft()
      };

      viewport.right = viewport.left + win.width();
      viewport.bottom = viewport.top + win.height();

      bounds = this.offset();
      bounds.right = bounds.left + this.outerWidth();
      bounds.bottom = bounds.top + this.outerHeight();

      // check if any of the bounds of the object is inside the viewport. If so return true.
      return (!(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom));
    };
  },

  // state
  getInitialState() {
    return {
      onScreen: false,
      inReplacementMode: true,
      inThirdQuartile: false,
      playerEventsToWatch: ['doPlay', 'doStop', 'doPause', 'doSeek', 'changeVolume', 'firstPlay', 'playerPlayEnd', 'thirdQuartile', 'playerPlayed']
    };
  },

  setupPlayerReplacement() {

    // define on screen handling function jQuery.fn.isOnScreen
    this.defineIsOnScreen();

    // setup players with ads
    this.setupPlayerWithAds();

    // start playing video in non mobile browsers if autoPlay feature is activated. The video has to be started even before the user scrolls or interacts with the page.
    if (this.props.autoPlay && !this.isMobile() && this.onScreenChangeHandlingOfPlayerWithoutAds) {
      this.onScreenChangeHandlingOfPlayerWithoutAds();
    }

    // watch onScreen changes (player with ads goes/leaves visible screen area f.ex. when scrolling down a page)
    this.setupOnScreenChangeHandlingOfPlayerWithoutAds();
  },

  setupOnScreenChangeHandlingOfPlayerWithoutAds() {
    var $ = jQuery;
    if (typeof(window) !== 'undefined') {
      // listen if video goes on screen to automatically play it if autoPlay feature is activated and the browser is not mobile.
      if (this.props.autoPlay && !this.isMobile()) {
        $(window).on('DOMContentLoaded load resize scroll', this.onScreenChangeHandlingOfPlayerWithoutAds);
      }
    }
  },

  onScreenChangeHandlingOfPlayerWithoutAds() {
    // handle player: start auto-playing when visible
    var onScreenVisibilityChanged = function() {
      var kdp = document.getElementById(this.props.kalturaID);

      if (!this.state.onScreen) {
        kdp.sendNotification('doPlay');
      }
    };

    var onScreenCurrently = jQuery('#' + this.props.kalturaID).isOnScreen();
    if (onScreenCurrently !== this.state.onScreen) {
      onScreenVisibilityChanged.apply(this);
    }

    this.setState({
      onScreen: onScreenCurrently
    });
  },

  setupPlayerWithAds() {
    var self = this;

    var initPlayerWithAds = function(i) {

      // listen for events to setup player with ads
      var j = self.state.playerEventsToWatch[i];
      var kdp = document.getElementById(self.props.kalturaID);
      var triggerPlayerReplacement = function() {

        if (self.state.inReplacementMode) {
          kWidget.destroy(self.props.kalturaID);
          kWidget.embed(self.state.playerWithAdsConfig);
        }

        // track NetMetrix on player replacement (new player starts auto-playing)
        self.track(Tracking.EVENT, {
          event: 'videoAutoPlay',
          id: this.props.kaltura_id
        });

      };

      // trigger player replacement on pause and seek events
      kdp.kBind(j, function() {
        if (j === 'doPause' || j === 'doSeek') {
          triggerPlayerReplacement();
        }
      });


      // Temporarily deactivate player replacement by setting state (replacement mode & inThirdQuartile)
      //
      // Problem: Player replacement is triggered by events doPause (clicking on view area or pause button) and doSeek (click on the progess bar).
      // Once the playhead reaches the end unfortunately the first event that is triggered is doPause.
      // This means the doPause event triggers player replacement without user interaction which is unacceptable.
      //
      // Solution (hacky): Remove player replacement on doPause event at the latest time possible which is on the thirdQuartile event (when fourth quartile is reached).
      // Additionally, setup player replacement on doPlay event once the playhead reaches the end and playerPlayEnd event is fired. This makes sure once the video finishes playing clicking on the view area or the play button does trigger player replacement.
      //
      // Limitations: Temporarily removing player replacement on doPause makes it impossible for the user to restart the video unmuted by clicking on the view are or the pause button (both trigger doPause events) in the fourth quartile.
      if (j === 'thirdQuartile') {

        // deactivate replacement mode on doPause and activate it on doSeek for the last quartile
        kdp.kBind('thirdQuartile', function() {
          // Switch to non replacement mode. Make sure component ist NOT updated on changing the state. We will handle player replacements outside of react.
          this.setState({
            inReplacementMode: false, // reliable - use instead of unbinding doPause event which is NOT reliable: kdp.kUnbind('doPause');
            inThirdQuartile: true
          });
        });

        // activate player replacement on doPlay when end of video is reached
        kdp.kBind('playerPlayEnd', function() {
          kdp.kBind('doPlay', function() {
            // Switch to replacement mode. Make sure component ist NOT updated on changing the state. We will trigger replacement manually below.
            this.setState({
              inReplacementMode: true, // reliable - use instead of unbinding doPause event which is NOT reliable: kdp.kUnbind('doPause');
              inThirdQuartile: false
            });
          });
        });
      }
    };

    // setup players with ads
    jQuery.each(this.state.playerEventsToWatch, initPlayerWithAds);
  },

  shouldComponentUpdate(nextProps) {
    // make sure the component re-renders when source is updated
    // source is loaded asynchronously
    if (nextProps.caption.source !== this.props.caption.source) {
      return true;
    }

    return false;
  }

};
