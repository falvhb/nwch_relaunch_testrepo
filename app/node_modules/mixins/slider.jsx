/*global Flickity:true*/
import _ from 'lodash';

export default {

  // Breakpoint under which Flickity should be initialized
  breakpoint: 640,
  // Contains the instance of Flickity once initialized
  flickity: null,
  // The selector on which Flickity should be initialized
  flickityElement: null,
  // Index for the starting slide (zero for default)
  startingIndex: 0,
  // The options with which Flickity should be initialized
  flickityOptions: {
    freeScroll: false,
    prevNextButtons: false,
    pageDots: false,
  },

  getViewportWidth() {
    return Math.max(document.documentElement.clientWidth, window.innerWidth);
  },

  startResize() {
    this.setState({ resizing: true });
  },

  stopResize() {
    this.setState({ resizing: false });
  },

  handleResize() {
    this.setState({
      mobile: this.getViewportWidth() < this.breakpoint
    });
  },

  setupFlickity(component) {
    window.addEventListener('resize', _.debounce(component.startResize, 350, { leading: true }));
    window.addEventListener('resize', _.debounce(component.stopResize, 350, { trailing: true }));
    window.addEventListener('resize', _.debounce(component.handleResize, 250));
    component.handleResize();
  },

  testForInit(component) {
    if (component.getViewportWidth() <= component.breakpoint) {
      this.initFlickity();
    } else {
      this.setState({ loading: false });
    }
  },

  renderFlickity(params) {
    var wait = params.delay || 0, self = this;
    this.flickityElement = params.element;
    this.startingIndex = params.startIndex || 0;
    setTimeout(function() {
      self.setupFlickity(self);
      self.testForInit(self);
    }, wait);
  },

  componentDidUpdate() {
    if (this.state.mobile) {
      this.initFlickity();
    } else if (this.flickity !== null) {
      this.destroyFlickity();
    }
  },

  updateHeight(params) {
    var items = params.slider.getCellElements(), i;
    var height = params.destroy ? '' : params.slider.maxCellHeight + 'px';
    for (i = 0; i < items.length; ++i) {
      items[i].style.height = height;
    }
  },

  initFlickity() {
    if (typeof Flickity !== 'undefined' && !this.flickity) {
      var self = this;
      this.flickity = new Flickity(this.flickityElement, this.flickityOptions);
      this.updateHeight({
        slider: this.flickity
      });
      setTimeout(function() {
        self.setState({ loading: false, resizing: false });
      }, 500);
    }
  },

  destroyFlickity() {
    if (typeof this.flickity.destroy === 'function') {
      this.updateHeight({
        slider: this.flickity,
        destroy: true
      });
      this.flickity.destroy();
      this.flickity = null;
    }
  },

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
    this.destroyFlickity();
  }

};
