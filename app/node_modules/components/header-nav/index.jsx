import React from 'react';
import bem from 'react-bem-helper';
import _ from 'lodash';
import Icon from 'components/icon';
import PrimaryNav from 'components/primary-nav';
import HeaderLogo from 'components/header-logo';
import DomainVariations from 'config/domain-variations';
import NavItems from 'config/nav-items';

const classes = new bem({
  name: 'header-nav',
  prefix: ''
});

export default React.createClass({

  displayName: 'HeaderNav',

  propTypes: {
    skin: React.PropTypes.string
  },

  getInitialState() {
    return {
      fixed: false,
      slim: false,
      open: true
    };
  },

  lastScroll: 0,

  breakpoint: 900,

  headerHeight: 150,

  getHeaderHeight() {
    return React.findDOMNode(this.isMobile() ? this.refs.headerBrand : this.refs.headerNav).offsetHeight;
  },

  isMobile() {
    return this.getViewportWidth() <= this.breakpoint;
  },

  getViewportWidth() {
    return Math.max(document.documentElement.clientWidth, window.innerWidth);
  },

  fixNavigation() {
    this.setState({ fixed: true });
  },

  unfixNavigation() {
    this.setState({ fixed: false });
  },

  slimNavigation() {
    this.setState({ slim: true });
  },

  unslimNavigation() {
    this.setState({ slim: false });
  },

  openNavigation() {
    this.setState({ open: true });
  },

  closeNavigation() {
    this.setState({ open: false });
  },

  mobileScrollBehvaiour() {
    // when back at the top
    if (window.scrollY <= 0) {
      this.unfixNavigation();
    }

    // when scrolling down
    if (window.scrollY > this.lastScroll && this.state.fixed) {
      // and the nav isn't open
      if (!this.state.open) {
        this.unfixNavigation();
      }
    }

    // when scrolling up
    if (window.scrollY < this.lastScroll && !this.state.fixed) {
      this.fixNavigation();
    }
  },

  desktopScrollBehvaiour() {
    // when back at the top
    if (window.scrollY <= 0) {
      this.unfixNavigation();
    }

    // when scrolling down
    if (window.scrollY > this.lastScroll && this.state.fixed) {
      this.unfixNavigation();
    }

    // when scrolling below the header
    if (window.scrollY > this.headerHeight) {
      this.slimNavigation();
      this.closeNavigation();

      // scrolling back up
      if (window.scrollY < this.lastScroll && !this.state.fixed) {
        this.fixNavigation();
      }
    } else {
      // otherwise, always show full nav
      this.unslimNavigation();
      this.openNavigation();
    }

    // when scrolling down
    if (window.scrollY > this.lastScroll && this.state.fixed) {
      this.unfixNavigation();
      this.closeNavigation();
    }
  },

  checkScrollPosition() {
    if (this.isMobile()) {
      this.mobileScrollBehvaiour();
    } else {
      this.desktopScrollBehvaiour();
    }

    // update the last scroll position
    this.lastScroll = window.scrollY;
  },

  toggleNavigation() {
    this.setState({ open: !this.state.open });
  },

  mappedNavItems(items) {
    let { skin } = this.props;
    if (skin in DomainVariations) {
      items.splice(1, 0, {
        href: DomainVariations[skin].href,
        label: DomainVariations[skin].label
      });
    }
    return items;
  },

  getActiveSection(path) {
    let segments = path.match(/\/(\w|-)+/g);
    return segments.length > 2 ? segments[0] : '/';
  },

  handleResize() {
    this.headerHeight = this.getHeaderHeight();
    if (this.isMobile()) {
      this.setState({ mobile: true });
    } else {
      this.setState({ mobile: false });
    }
  },

  componentDidMount() {
    this.scrollHandler = _.throttle(this.checkScrollPosition, 150);
    document.addEventListener('scroll', this.scrollHandler, 150);
    this.resizeHandler = _.throttle(this.handleResize, 150);
    window.addEventListener('resize', this.resizeHandler, 150);
    if (this.isMobile()) {
      this.setState({
        mobile: true,
        open: false
      });
    }
  },

  componentDidUpdate(prevProps, prevState) {
    // when switching views
    if (prevState.mobile !== this.state.mobile) {
      this.getHeaderHeight();
      if (this.state.mobile) {
        // auto-close nav
        this.closeNavigation();
      }
      if (window.scrollY <= this.headerHeight && !this.state.mobile) {
        this.unslimNavigation();
        this.openNavigation();
      } else {
        this.slimNavigation();
      }
    }
  },

  render() {
    const { path } = this.props;
    const { fixed, slim, open, mobile } = this.state;
    const navItems = NavItems.slice();

    let headerClasses = {
      'is-fixed': fixed,
      'is-slim': slim,
      'is-mobile': mobile,
    };

    return (
      <header {...classes(null, 'main', headerClasses)} ref='headerNav'>
        <div {...classes('brand')} ref='headerBrand'>
          <div {...classes('container')}>
            <div {...classes('brand-wrap')}>
              <div {...classes('toggle-wrap')}>
                <button {...classes('trigger')} onClick={this.toggleNavigation}>
                  {open
                    ? <Icon id="close"/>
                    : <Icon id="menu"/>
                  }
                  <span>Menu</span>
                </button>
              </div>
              <span {...classes('logo', [slim || mobile ? 'slim' : 'regular'])}>
                <HeaderLogo id={this.props.skin} />
              </span>
            </div>
          </div>
        </div>
        <div {...classes('toggle', null, [this.state.open ? 'is-open' : 'is-closed'])}>
          <div {...classes('container')}>
            <PrimaryNav items={this.mappedNavItems(navItems)} active={this.getActiveSection(path)} />
          </div>
        </div>
      </header>
    );
  }

});
