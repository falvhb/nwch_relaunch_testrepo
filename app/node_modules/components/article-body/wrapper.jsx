import React from 'react';
import _ from 'lodash';
import { cleanContent } from 'helpers/string';

export default Component => React.createClass({

  displayName: 'ArticleBodyWrapper',

  propTypes: {
    author: React.PropTypes.string,
    text: React.PropTypes.string.isRequired,
    enrichments: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
    related: React.PropTypes.arrayOf(React.PropTypes.object)
  },

  markers: {
    related: '${{empfehlung}}',
    enrichment: '${{stoerer}}'
  },

  escapeRegExp(s) {
    return s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
  },

  getContentMatches(content, separator) {
    const regex = new RegExp(this.escapeRegExp(separator), 'g');
    if (content.match(regex)) return content.match(regex).length;
  },

  enrichmentsToArray(params) {

    const { text, total } = params;
    const separator = this.markers.enrichment.toString();

    let mappedContent = [];
    let itemsArray = text.split(separator);

    // loop each item in the array
    _.forEach(itemsArray, function(item, index) {

      let contentString = cleanContent(item).trim();

      // if we have a corresponding enrichment in API data
      if (index < total) {

        // if it's an empty string...
        // there were two enrichments next to each other or the item has no useful content
        if (_.isEmpty(item.trim()) || _.isEmpty(contentString)) {
          mappedContent.push(separator);
          return;
        }

        // if there's content after cleaning
        if (contentString) {
          // there was an item first
          mappedContent.push(item);
          // then another enrichment
          mappedContent.push(separator);
          return;
        }
      }

      // or if there's still an item
      if (item && !_.isEmpty(contentString)) {
        mappedContent.push(item);
        return;
      }

    });

    return mappedContent;
  },

  enrichmentsWithRelated(params) {
    const { text, total } = params;
    const relatedSeparator = this.markers.related.toString();

    let beforeRelated = [], afterRelated = [];
    let splitByRelated = text.split(relatedSeparator);
    let contentBeforeRelated = splitByRelated[0];
    let contentAfterRelated = splitByRelated[1];

    // get content before recommendations
    if (contentBeforeRelated) {
      let countEnrichmentsBefore = this.getContentMatches(contentBeforeRelated, this.markers.enrichment.toString());
      beforeRelated = this.enrichmentsToArray({
        text: contentBeforeRelated,
        total: Math.min(countEnrichmentsBefore, total)
      });
    }

    // get content after recommendations
    if (contentAfterRelated) {
      let countEnrichmentsAfter = this.getContentMatches(contentAfterRelated, this.markers.enrichment.toString());
      afterRelated = this.enrichmentsToArray({
        text: contentAfterRelated,
        total: Math.min(countEnrichmentsAfter, total)
      });
    }

    // merge 3 parts in order
    return beforeRelated.concat(relatedSeparator, afterRelated);
  },

  createEnrichmentsObject(array, props) {
    const self = this;
    const { enrichments, author, related } = props;

    let mappedContent = [], enrichmentIndex = 0;

    _.forEach(array, function(item) {

      // for enrichments
      if (item === self.markers.enrichment) {
        let enrichment = enrichments[enrichmentIndex];
        enrichmentIndex++;
        return mappedContent.push({
          type: enrichment.stoerer_type || enrichment.asset.content_type,
          data: enrichment
        });
      }

      // for related articles
      if (item === self.markers.related) {
        return mappedContent.push({
          type: 'curated_recommendations',
          data: {
            author: author,
            teasers: related
          }
        });
      }

      // default (text block)
      return mappedContent.push({
        type: 'content_block',
        data: item
      });

    });

    return mappedContent;
  },

  mapBodyContent(props) {

    const apiTextBody = props.text;
    const total = props.enrichments.length;
    const containsRelated = _.includes(apiTextBody, this.markers.related);
    const containsEnrichments = _.includes(apiTextBody, this.markers.enrichment);

    const createArrayProps = {
      text: apiTextBody,
      total: total
    };

    // return the default API text if no related / enrichments
    if (!containsRelated && !containsEnrichments) {
      return [{
        type: 'content_block',
        data: apiTextBody
      }];
    }

    let enrichmentsArray;

    // if we have both enrichments and recommendations
    if (containsRelated) {
      enrichmentsArray = this.enrichmentsWithRelated(createArrayProps);
    } else {
      // we just have enrichments
      enrichmentsArray = this.enrichmentsToArray(createArrayProps);
    }

    return this.createEnrichmentsObject(enrichmentsArray, props);
  },

  mappedData(props) {
    return {
      content: this.mapBodyContent(props)
    };
  },

  render() {
    return (
      <Component {...this.mappedData(this.props)} />
    );
  }

});
