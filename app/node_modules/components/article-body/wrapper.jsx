import React from 'react';
import _ from 'lodash';
import sanitizeHtml from 'sanitize-html';

// import CuratedRecommendations from 'components/curated-recommendations';
// import RawContent from 'components/raw-content';

export default Component => React.createClass({

  displayName: 'ArticleBodyWrapper',

  propTypes: {
    author: React.PropTypes.string,
    text: React.PropTypes.string.isRequired,
    enrichments: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
    related: React.PropTypes.arrayOf(React.PropTypes.object)
  },

  markers: {
    related: '${{empfehlung}}',
    enrichment: '${{stoerer}}'
  },

  cleanContent(content) {
    let emptyTags = ['a', 'p', 'div', 'table', 'th', 'td', 'h1', 'h2', 'h3', 'ul', 'ol', 'li', 'strong', 'em'];

    return sanitizeHtml(content, {
      exclusiveFilter: function(frame) {
        var text = frame.text.trim();
        return _.includes(emptyTags, frame.tag) && (!text || text === '&nbsp;');
      }
    });
  },

  enrichmentsToArray(params) {
    const self = this;
    const separator = this.markers.enrichment.toString();
    const textBody = params.parse;
    const total = params.count;

    let mappedContent = [];
    let itemsArray = textBody.split(separator);

    _.forEach(itemsArray, function(item, index) {

      // if we have a corresponding enrichment in API data
      if (index < total) {

        // if it's an empty string...
        // there were two enrichments next to each other or the item has no useful content
        if (_.isEmpty(item.trim()) || _.isEmpty(self.cleanContent(item).trim())) {
          mappedContent.push(separator);
          return;
        }

        // if there's content after cleaning
        if (self.cleanContent(item).trim()) {
          // there was an item first
          mappedContent.push(item);
          // then another enrichment
          mappedContent.push(separator);
          return;
        }
      }

    });

    return mappedContent;
  },

  createEnrichmentsObject(array, enrichments) {
    const self = this;
    let mappedContent = [];

    _.forEach(array, function(item, index) {
      if (index < enrichments.length) {
        return mappedContent.push({
          type: item === self.markers.enrichment
            ? enrichments[index].stoerer_type
            : 'content_block',
          data: item === self.markers.enrichment
            ? enrichments[index]
            : self.cleanContent(item)
        });
      }
    });

    return mappedContent;
  },

  mapBodyContent(props) {
    const apiTextBody = props.text;
    const containsRelated = _.includes(apiTextBody, this.markers.related);
    const containsEnrichments = _.includes(apiTextBody, this.markers.enrichment);

    // return the default API text if no related / enrichments
    if (!containsRelated && !containsEnrichments) {
      return [{
        type: 'text',
        data: apiTextBody
      }];
    }

    // get an array of all our items
    const enrichmentsArray = this.enrichmentsToArray({
      parse: props.text,
      count: props.enrichments.length
    });

    return this.createEnrichmentsObject(enrichmentsArray, props.enrichments);
  },

  mappedData(props) {
    return {
      content: this.mapBodyContent(props)
    };
  },

  render() {
    return (
      <Component {...this.mappedData(this.props)} />
    );
  }

});
