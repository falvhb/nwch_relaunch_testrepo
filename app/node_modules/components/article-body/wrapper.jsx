import React from 'react';

import GetEnrichment from 'helpers/get-enrichment';
import CuratedRecommendations from 'components/curated-recommendations';
import RawContent from 'components/raw-content';
import Aside from 'components/aside';

export default Component => React.createClass({

  displayName: 'ArticleBodyWrapper',

  propTypes: {
    text: React.PropTypes.string.isRequired,
    enrichments: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
    curated: React.PropTypes.arrayOf(React.PropTypes.object),
    author: React.PropTypes.string,
    intro: React.PropTypes.string,
    tags: React.PropTypes.arrayOf(React.PropTypes.string),
    title: React.PropTypes.string
  },

  tokens: {
    enrichment: 'stoerer',
    curated: 'empfehlung'
  },

  formatToken(token) {
    return '${{' + token + '}}';
  },

  escapeRegExp(reg) {
    var specialChars = [ '$', '^', '*', '(', ')', '+', '[', ']', '{', '}', '\\', '|', '.', '?', '/' ];
    var regex = new RegExp('(\\' + specialChars.join('|\\') + ')', 'g');
    return reg.replace(regex, '\\$1');
  },

  getRegExp(tokens) {
    // Create and escape a dummy token (to avoid escaping the `|`)
    var dummyToken = this.escapeRegExp(this.formatToken('foobar'));
    // Then replace the dummy token with actual tokens joined with `|`
    var regex = dummyToken.replace('foobar', '(' + tokens.join('|') + ')');
    // Return the new dynamically created regular expression
    return new RegExp(regex, 'g');
  },

  getTokens() {
    return Object.keys(this.tokens).map((key) => {
      return this.tokens[key];
    });
  },

  mapContentAndEnrichments(props) {
    var content = [];
    var tokenRegExp = this.getRegExp(this.getTokens());
    var text = props.text;
    var enrichments = props.enrichments;
    var enrichmentIndex = 0;
    var rawIndex = 0;
    var curated = false;
    var index = text.search(tokenRegExp);
    var currentToken = '';
    var currentTokenType = '';
    var tokenMatches;

    // While there are tokens in the content and we still have interferers left
    // to display, keep going
    while (index > -1 && enrichmentIndex < enrichments.length) {
      tokenMatches = tokenRegExp.exec(text);

      if (tokenMatches && tokenMatches.length >= 2) {
        currentToken = tokenMatches[0];
        currentTokenType = tokenMatches[1];
      }

      // Unless the token is at the very beginning, push the content before the
      // token in the `content` array
      if (index > 0) {
        content.push(<RawContent key={'raw' + rawIndex} content={text.slice(0, index)} />);
        rawIndex += 1;
      }

      // If the curated section has not been spotted yet and we deal with the
      // token for the curated section, push the curated recommendations
      // component in the `content` array and put curated to true
      if (!curated && currentTokenType === this.tokens.curated) {
        content.push(<CuratedRecommendations key='curated' author={props.author} teasers={props.curated} />);
        curated = true;
      } else {
        var enrichment = enrichments[enrichmentIndex];

        if (enrichment) {
          var Enrichment = <GetEnrichment key={'enrichment_' + enrichmentIndex} enrichment={enrichment} />;
          var wrapped = enrichment.placement && ['left', 'right'].indexOf(enrichment.placement) > -1;
          content.push(wrapped ? <Aside key={'enrichmentAside_' + enrichmentIndex}>{Enrichment}</Aside> : Enrichment);
          enrichmentIndex += 1;
        }
      }
      // reduce the text to start after current enrichment token
      text = text.slice(index + currentToken.length);
      // find index of next enrichment token
      index = text.search(tokenRegExp);
    }

    // Deal with the end of content
    if (text.length > 0) {
      // Get rid of any extra token
      text = this.cleanRemainingTokens(text);

      // Push the last portion of text to `content` array
      content.push(<RawContent key='rawLast' content={text} />);
    }

    return content;
  },

  cleanRemainingTokens(text) {
    return text.replace(this.getRegExp(this.getTokens()), '');
  },

  mappedData(props) {
    return {
      content: this.mapContentAndEnrichments(props),
      intro: this.props.intro,
      tags: this.props.tags,
      title: this.props.title
    };
  },

  render() {
    return (
      <Component {...this.mappedData(this.props)} />
    );
  }

});
