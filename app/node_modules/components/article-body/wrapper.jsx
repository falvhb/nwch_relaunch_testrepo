import React from 'react';

import GetEnrichment from 'helpers/get-enrichment';
import CuratedRecommendations from 'components/curated-recommendations';
import RawContent from 'components/raw-content';
import EnrichmentWrap from 'components/enrichment';

export default Component => React.createClass({

  displayName: 'ArticleBodyWrapper',

  propTypes: {
    author: React.PropTypes.string,
    text: React.PropTypes.string.isRequired,
    enrichments: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
    related: React.PropTypes.arrayOf(React.PropTypes.object)
  },

  tokens: {
    enrichment: 'stoerer',
    curated: 'empfehlung'
  },

  formatToken(token) {
    return '${{' + token + '}}';
  },

  content: [],

  enrichmentIndex: 0,

  disallowedEnrichments: ['survey_stoerer', 'map_stoerer'],

  escapeRegExp(reg) {
    var specialChars = [ '$', '^', '*', '(', ')', '+', '[', ']', '{', '}', '\\', '|', '.', '?', '/' ];
    var regex = new RegExp('(\\' + specialChars.join('|\\') + ')', 'g');
    return reg.replace(regex, '\\$1');
  },

  getRegExp(tokens) {
    // Create and escape a dummy token (to avoid escaping the `|`)
    var dummyToken = this.escapeRegExp(this.formatToken('foobar'));
    // Then replace the dummy token with actual tokens joined with `|`
    var regex = dummyToken.replace('foobar', '(' + tokens.join('|') + ')');
    // Return the new dynamically created regular expression
    return new RegExp(regex, 'g');
  },

  getTokens() {
    return Object.keys(this.tokens).map((key) => {
      return this.tokens[key];
    });
  },

  getEnrichment(enrichment) {
    var enrichmentType = enrichment.stoerer_type || enrichment.asset.content_type;
    if (this.disallowedEnrichments.indexOf(enrichmentType) === -1) {
      var Enrichment = <GetEnrichment key={'enrichment_' + this.enrichmentIndex} enrichment={enrichment} />;
      var aside = enrichment.placement && ['left', 'right'].indexOf(enrichment.placement) > -1 ? true : false;
      this.content.push(
        <EnrichmentWrap
          key={'enrichmentWrap_' + this.enrichmentIndex}
          type={enrichmentType}
          aside={aside}>
          {Enrichment}
        </EnrichmentWrap>
      );
    }
  },

  mapContentAndEnrichments(props) {
    var tokenRegExp = this.getRegExp(this.getTokens());
    var text = props.text;
    var enrichments = props.enrichments;
    var rawIndex = 0;
    var curated = false;
    var index = text ? text.search(tokenRegExp) : false;
    var currentToken = '';
    var currentTokenType = '';
    var tokenMatches;

    // While there are tokens in the content and we still have interferers left
    // to display, keep going
    while (index > -1 && this.enrichmentIndex < enrichments.length) {
      tokenMatches = tokenRegExp.exec(text);

      if (tokenMatches && tokenMatches.length >= 2) {
        currentToken = tokenMatches[0];
        currentTokenType = tokenMatches[1];
      }

      // Unless the token is at the very beginning, push the content before the
      // token in the `content` array
      if (index > 0) {
        this.content.push(<RawContent key={'raw' + rawIndex} content={text.slice(0, index)} />);
        rawIndex += 1;
      }

      // If the curated section has not been spotted yet and we deal with the
      // token for the curated section, push the curated recommendations
      // component in the `content` array and put curated to true
      if (!curated && currentTokenType === this.tokens.curated) {
        this.content.push(<CuratedRecommendations key='curated' author={props.author} teasers={props.related} />);
        curated = true;
      } else {
        var enrichment = enrichments[this.enrichmentIndex];
        if (enrichment) {
          this.getEnrichment(enrichment);
        }
        this.enrichmentIndex += 1;
      }
      // reduce the text to start after current enrichment token
      text = text.slice(index + currentToken.length);
      // find index of next enrichment token
      index = text.search(tokenRegExp);
    }

    // Deal with the end of content
    if (text && text.length > 0) {
      // Get rid of any extra token
      text = this.cleanRemainingTokens(text);

      // Push the last portion of text to `content` array
      this.content.push(<RawContent key='rawLast' content={text} />);
    }

    return this.content;
  },

  cleanRemainingTokens(text) {
    return text.replace(this.getRegExp(this.getTokens()), '');
  },

  mappedData(props) {
    return {
      content: this.mapContentAndEnrichments(props)
    };
  },

  render() {
    return (
      <Component {...this.mappedData(this.props)} />
    );
  }

});
