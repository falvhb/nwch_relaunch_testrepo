/*global Flickity:true*/
import React from 'react';
import bem from 'react-bem-helper';
import _ from 'lodash';

import Wrapper from './wrapper';
import Teaser from 'components/teaser';

const classes = new bem({
  name: 'curated-recommendations',
  prefix: ''
});

const CuratedRecommendations = React.createClass({

  displayName: 'CuratedRecommendations',

  propTypes: {
    author: React.PropTypes.string,
    teasers: React.PropTypes.array.isRequired
  },

  // Breakpoint under which Flickity should be initialized
  breakpoint: 640,
  // Contains the instance of Flickity once initialized
  flickity: null,
  // The selector on which Flickity should be initialized
  flickityElement: '.init-slider',
  // The options with which Flickity should be initialized
  flickityOptions: {
    freeScroll: false,
    prevNextButtons: false,
    pageDots: false,
  },

  getInitialState() {
    return {
      // No JS / server.js
      support: false,
      // Initiale state is not mobile
      mobile: false
    };
  },

  getDefaultProps() {
    return {
      author: ''
    };
  },

  // Return the viewport width
  getViewportWidth() {
    return Math.max(document.documentElement.clientWidth, window.innerWidth);
  },

  // Method called when the window gets resized; redefines the `mobile` state
  handleResize() {
    this.setState({
      mobile: this.getViewportWidth() < this.breakpoint
    });
  },

  componentDidMount() {
    window.addEventListener('resize', _.debounce(this.handleResize, 250));

    // Redefine the `mobile` state
    this.handleResize();

    // Redefine the `support` state
    this.setState({
      support: true
    });

    // Re-perform the mobile check as `.setState(..)` is asynchronous
    if (this.getViewportWidth() <= this.breakpoint && this.state.support) {
      this.initSlider();
    }
  },

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
    this.destroySlider();
  },

  updateHeight(params) {
    var items = params.slider.getCellElements(), i;
    var height = params.destroy ? '' : params.slider.maxCellHeight + 'px';
    for (i = 0; i < items.length; ++i) {
      items[i].style.height = height;
    }
  },

  // Initialize Flickity
  initSlider() {
    this.flickityOptions.initialIndex = Math.floor(this.props.teasers.length / 2);
    // Break in case Flickity is not loaded for some reason
    // or if the slider is already initialized
    if (typeof Flickity !== 'undefined' && !this.flickity) {
      this.flickity = new Flickity(this.flickityElement, this.flickityOptions);
      this.updateHeight({
        slider: this.flickity
      });
    }
  },

  // Remove Flickity
  destroySlider() {
    if (typeof this.flickity.destroy === 'function') {
      this.updateHeight({
        slider: this.flickity,
        destroy: true
      });
      this.flickity.destroy();
      this.flickity = null;
    }
  },

  componentDidUpdate() {
    if (this.state.mobile && this.state.support) {
      this.initSlider();
    } else if (this.flickity !== null) {
      this.destroySlider();
    }
  },

  render() {
    var props = this.props;

    var multiple = props.teasers.length > 1;

    var modifiers = {
      'multiple': multiple,
    };

    modifiers['count-' + props.teasers.length] = true;

    return (
      <div {...classes(null, modifiers)}>
        {props.author
          ? <h3 {...classes('title')}>{props.author + ' empfiehlt'}</h3>
          : ''
        }
        <div {...classes('grid', null, (multiple ? 'init-slider' : ''))}>
          {props.teasers.map((teaser, index) =>
            <div {...classes('item')} key={index}>
              <Teaser key={index} {...teaser} modifier='light-boxed' />
            </div>
          )}
        </div>
      </div>
    );
  }

});

export default Wrapper(CuratedRecommendations);
