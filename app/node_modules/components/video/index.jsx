import React from 'react';
import jQuery from 'jQuery';
import objectAssign from 'react/lib/Object.assign';
import bem from 'react-bem-helper';

import ResponsiveVideoMixin from 'mixins/responsive-video';

const classes = new bem({
  name: 'video',
  prefix: ''
});

const Video = React.createClass({

  mixins: [ResponsiveVideoMixin],

  propTypes: {
    accountID: React.PropTypes.string.isRequired,
    playerID: React.PropTypes.string.isRequired,
    playerID2: React.PropTypes.string.isRequired,
    trackingURL: React.PropTypes.string.isRequired,
    kalturaID: React.PropTypes.string.isRequired,
    title: React.PropTypes.string.isRequired,
    description: React.PropTypes.string.isRequired,
    thumbImageURL: React.PropTypes.string.isRequired,
    source: React.PropTypes.string.isRequired,
    autoPlay: React.PropTypes.bool
  },

  getDefaultProps: function() {
    return {
      autoPlay: false
    };
  },

  // utilities
  removePTags: function(string) {
    return string.replace(/(<p[^>]+?>|<p>|<\/p>)/img, " ");
  },
  isMobile: function() {
    if ( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
      return true;
    }
    return false;
  },
  defineIsOnScreen: function() {
    // define jQuery plugin used for checking if an DOM node is on screen
    jQuery.fn.isOnScreen = function() {
      var win = jQuery(window);

      var viewport = {
        top: win.scrollTop(),
        left: win.scrollLeft()
      };
      viewport.right = viewport.left + win.width();
      viewport.bottom = viewport.top + win.height();

      var bounds = this.offset();
      bounds.right = bounds.left + this.outerWidth();
      bounds.bottom = bounds.top + this.outerHeight();

      return (!(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom));

    };
  },

  // state
  getInitialState: function() {
    return {
      onScreen: false,
      inReplacementMode: true,
      inThirdQuartile: false,
      playerEventsToWatch: ['doPlay', 'doStop', 'doPause', 'doSeek', 'changeVolume', 'firstPlay', 'playerPlayEnd', 'thirdQuartile', 'playerPlayed']
    };
  },
  // setup players (using external Kaltura Media Player library)
  getPlayerLibraryURLs: function(forPlayerWithoutAds) {
    var playerID = (forPlayerWithoutAds===true) ? this.props.playerID : this.props.playerID2;
    return "http://cdnapi.kaltura.com/p/"
                          + this.props.accountID
                          + "/sp/"
                          + this.props.accountID
                          + "00/embedIframeJs/uiconf_id/"
                          + playerID
                          + "/partner_id/"
                          + this.props.accountID;
  },
  loadPlayers: function() {

    // load both players using promises
    var self = this;
    jQuery.when(
      jQuery.getScript( this.getPlayerLibraryURLs(true) ),
      jQuery.getScript( this.getPlayerLibraryURLs(false) ),
      jQuery.Deferred(function(deferred) {
        jQuery( deferred.resolve );
      })
    ).done(function() {
        var playerWithoutAdsConfig = {
          'targetId': self.props.kalturaID,
          'wid': '_'+self.props.accountID,
          'uiconf_id': self.props.playerID2,
          'entry_id': self.props.kalturaID,
          'flashvars': {
            'EmbedPlayer.EnableFullscreen': false,
            'autoMute': true
          },
          'readyCallback': self.setupPlayerReplacement
        };

        // set configuration object for player with ads
        self.setConfigurationForPlayerWithAds();

        // setup players (without ads if autoPlay is activated or if we are in non-mobile browsers)
        if (!self.props.autoPlay) {
          // console.log(self.props.kalturaID.toUpperCase()+':	'+'- Auto-play deactivated - setup player with ads and non-muted');
          kWidget.embed(self.state.playerWithAdsConfig);
        } else if (self.isMobile()) {
          // console.log(self.props.kalturaID.toUpperCase()+':	'+'- Mobile browser detected - setup player without ads and non-muted. ','Auto-Play: ',self.props.autoPlay,'Is Mobile: ',self.isMobile());
          kWidget.embed(self.state.playerWithAdsForMobileConfig);
        } else {
          kWidget.embed(playerWithoutAdsConfig);
        }

        // make players fluid (responsive)
        self.setupFixedRatioOnResizingVideo();

      });

  },
  setupPlayerReplacement: function() {

    // define on screen handling function jQuery.fn.isOnScreen
    this.defineIsOnScreen();

    // setup players with ads
    this.setupPlayerWithAds();

    // start playing video in non mobile browsers if autoPlay feature is activated. The video has to be started even before the user scrolls or interacts with the page.
    if (this.props.autoPlay && !this.isMobile()  && this.onScreenChangeHandlingOfPlayerWithoutAds) {
      this.onScreenChangeHandlingOfPlayerWithoutAds();
    }

    // watch onScreen changes (player with ads goes/leaves visible screen area f.ex. when scrolling down a page)
    this.setupOnScreenChangeHandlingOfPlayerWithoutAds();
  },
  setupOnScreenChangeHandlingOfPlayerWithoutAds: function() {
    var $ = jQuery;
    if (typeof(window)!=='undefined') {
      // listen if video goes on screen to automatically play it if autoPlay feature is activated and the browser is not mobile.
      if (this.props.autoPlay && !this.isMobile()) {
        $(window).on('DOMContentLoaded load resize scroll', this.onScreenChangeHandlingOfPlayerWithoutAds);
      }
    }
  },
  onScreenChangeHandlingOfPlayerWithoutAds: function() {
    // handle player: start auto-playing when visible
    var onScreenVisibilityChanged = function() {
      var kdp = document.getElementById(this.props.kalturaID);
      if (!this.state.onScreen) {
        // console.log(this.props.kalturaID.toUpperCase(),' - onScreenVisibilityChanged - ',':	became visible - trigger doPlay');
        kdp.sendNotification('doPlay');
      } else {
        // console.log(this.props.kalturaID.toUpperCase(),' - onScreenVisibilityChanged - ',':	was hidden');
      }
    };

    var onScreenCurrently = jQuery('#'+this.props.kalturaID).isOnScreen();
    if (onScreenCurrently!==this.state.onScreen) {
      onScreenVisibilityChanged.apply(this);
    }
    this.setState({
      onScreen: onScreenCurrently
    });
  },
  unmuteAndPlayPlayerWithAds: function() {
    var kdp = document.getElementById(this.props.kalturaID);
    var self = this;

    kdp.sendNotification('changeVolume', 0.8);

    // auto play the video if autoPlay feature is deactivated or if we are in non mobile browsers
    if (this.props.autoPlay && !this.isMobile()) {
      kdp.sendNotification('doPlay');
    }

    // track NetMetrix on doPlay if we autoPlay is deactivated or we are in a mobile browser
    if (!this.props.autoPlay || this.isMobile()) {
      // console.log('@TODO: NetMetrix tracking on video play event for autoPlay deactivated or in mobile browsers');
      kdp.kBind('doPlay.firstPlayTracking', function() {
        jQuery.get(self.props.trackingURL);
        kdp.kUnbind('doPlay.firstPlayTracking');
      });
    }

  },
  setConfigurationForPlayerWithAds: function() {
    var playerWithAdsConfig = {
        'targetId': ''+this.props.kalturaID,
        'wid': '_'+this.props.accountID,
        'uiconf_id': this.props.playerID,
        'entry_id': this.props.kalturaID,
        'flashvars': {
          'autoPlay': false,
          'autoMute': false,
          'adsOnReplay': true
        },
        'readyCallback': this.unmuteAndPlayPlayerWithAds
    };
    var playerWithAdsForMobileConfig = objectAssign(playerWithAdsConfig, {
    });

    this.setState({
      playerWithAdsConfig: playerWithAdsConfig,
      playerWithAdsForMobileConfig: playerWithAdsForMobileConfig
    });
  },
  setupPlayerWithAds: function() {
    var self = this;

    var setupPlayerWithAds = function(i) {

      // listen for events to setup player with ads
      var j = self.state.playerEventsToWatch[i];
      var kdp = document.getElementById(self.props.kalturaID);
      var triggerPlayerReplacement = function() {

        if (self.state.inReplacementMode) {
          kWidget.destroy(self.props.kalturaID);
          kWidget.embed(self.state.playerWithAdsConfig);
        }

        // track NetMetrix on player replacement (new player starts auto-playing)
        // console.log('@TODO: NetMetrix tracking on player replacement');
        jQuery.get(self.props.trackingURL);

      };

      // trigger player replacement on pause and seek events
      kdp.kBind(j, function() {
        if (j === 'doPause' || j === 'doSeek') {
          triggerPlayerReplacement();
        }
      });


      // Temporarily deactivate player replacement by setting state (replacement mode & inThirdQuartile)
      //
      // Problem: Player replacement is triggered by events doPause (clicking on view area or pause button) and doSeek (click on the progess bar).
      // Once the playhead reaches the end unfortunately the first event that is triggered is doPause.
      // This means the doPause event triggers player replacement without user interaction which is unacceptable.
      //
      // Solution (hacky): Remove player replacement on doPause event at the latest time possible which is on the thirdQuartile event (when fourth quartile is reached).
      // Additionally, setup player replacement on doPlay event once the playhead reaches the end and playerPlayEnd event is fired. This makes sure once the video finishes playing clicking on the view area or the play button does trigger player replacement.
      //
      // Limitations: Temporarily removing player replacement on doPause makes it impossible for the user to restart the video unmuted by clicking on the view are or the pause button (both trigger doPause events) in the fourth quartile.
      if (j==='thirdQuartile') {

        // deactivate replacement mode on doPause and activate it on doSeek for the last quartile
        kdp.kBind('thirdQuartile', function() {
          // console.log(self.props.kalturaID.toUpperCase()+':	'+'No Ads: thirdQuartile');

          // Switch to non replacement mode. Make sure component ist NOT updated on changing the state. We will handle player replacements outside of react.
          this.setState({
            inReplacementMode: false, // reliable - use instead of unbinding doPause event which is NOT reliable: kdp.kUnbind('doPause');
            inThirdQuartile: true
          });
        });

        // activate player replacement on doPlay when end of video is reached
        kdp.kBind('playerPlayEnd', function() {
          // console.log(self.props.kalturaID.toUpperCase()+':	', 'PLAYERPLAYEND: ', 'setup triggering of replay in new player on doPlay event.');

          kdp.kBind('doPlay', function() {
            // console.log(self.props.kalturaID.toUpperCase()+':	'+'doPlay fired after thirdQuartile:');

            // Switch to replacement mode. Make sure component ist NOT updated on changing the state. We will trigger replacement manually below.
            this.setState({
              inReplacementMode: true, // reliable - use instead of unbinding doPause event which is NOT reliable: kdp.kUnbind('doPause');
              inThirdQuartile: false
            });
          });
        });
      }
    };

    // setup players with ads
    jQuery.each(this.state.playerEventsToWatch, setupPlayerWithAds);
  },

  // react lifecycle
  shouldComponentUpdate: function() {
    return false;
  },
  componentDidMount: function() {
    this.loadPlayers();
  },

  render() {
    return (

      <div {...classes('container--outer')} itemProp="video" itemScope="" itemType="http://schema.org/VideoObject" >
        <div {...classes('container--inner')} ref="videoContainer" id={this.props.kalturaID} ></div>
        <h2 itemProp="name" {...classes('title')} >{this.props.title}</h2>
        <p itemProp="description" {...classes('description')} dangerouslySetInnerHTML={{ __html: this.removePTags(this.props.description)}} ></p>
        <p {...classes('source')} >Quelle: {this.props.source}</p>

        <meta itemProp="thumbnailUrl" content={this.props.thumbImageURL} />

        /* @TODO: Asked Lovely to add properties to API
        <meta itemProp="duration" content="T1M33S" />
        <meta itemProp="contentURL" content="http://www.example.com/video123.flv" />
        <meta itemProp="embedURL" content="http://www.example.com/videoplayer.swf?video=123" />
        <meta itemProp="uploadDate" content="2011-07-05T08:00:00+08:00" />
        <meta itemProp="expires" content="2012-01-30T19:00:00+08:00" />
        <meta itemProp="height" content="400" />
        <meta itemProp="width" content="400" />
        */
      </div>

    );
  }

});

module.exports = Video;
