import React from 'react';
import bem from 'react-bem-helper';

import EnrichmentText from 'components/enrichment-text';
import EnrichmentImage from 'components/enrichment-image';
import EnrichmentDownload from 'components/enrichment-download';
import RawContent from 'components/raw-content';
import Tags from 'components/tags';
import Aside from 'components/aside';

const classes = new bem({
  name: 'article-content',
  prefix: ''
});

export default React.createClass({

  propTypes: {
    lead: React.PropTypes.string.isRequired,
    keywords: React.PropTypes.array.isRequired,
    text: React.PropTypes.string.isRequired,
    stoerer: React.PropTypes.array.isRequired
  },

  getEnrichmentComponent(kind) {
    var kinds = {
      'text_stoerer': EnrichmentText,
      'image_stoerer': EnrichmentImage,
      'download_stoerer': EnrichmentDownload,
      // This is meant for the main asset which is not an interferer in itself
      // and has its own `content_type`. Still, we want it to behave the same
      // way as any other st√∂rer.
      'asset_image': EnrichmentImage
    };

    if (typeof kinds[kind] === 'undefined') {
      return false;
    }

    return kinds[kind];
  },

  getEnrichments() {
    var chunks = [];
    var token = '<p>${{stoerer}}</p>';
    var text = this.props.text
      // Remove junk from CMS
      .replace(/<p>(\s|&nbsp;)*<\/p>/g, '');
    var index = text.indexOf(token);
    var interfererIndex = 0, rawIndex = 0;

    // Look for token
    while (index > -1) {
      // If there is token, render raw content before token
      if (index > 0) {
        chunks.push(<RawContent key={'raw' + rawIndex} content={text.slice(0, index)} />);
        rawIndex += 1;
      }

      // Then render interferer
      var interferer = this.props.stoerer[interfererIndex];
      var Component = this.getEnrichmentComponent(interferer.stoerer_type);

      if (Component) {
        var wrapped = interferer.placement && ['left', 'right'].indexOf(interferer.placement) > -1;
        var Node = <Component key={'interferer' + interfererIndex} {...interferer} />;

        chunks.push(wrapped ? <Aside>{Node}</Aside> : Node);
      }

      // Update the remaining text
      text = text.slice(index + token.length);
      // Look for next token
      index = text.indexOf(token);
      interfererIndex += 1;
    }

    // Make sure we don't leave any content if there are more inteferers than content chunks
    if (text.length > 0) {
      chunks.push(<RawContent key='rawLast' content={text} />);
    }

    return chunks;
  },

  getMainAsset() {
    if (this.props.assets.length > 0) {
      return React.createElement(
        this.getEnrichmentComponent(this.props.assets[0].asset.content_type),
        this.props.assets[0]
      );
    }

    return undefined;
  },

  render() {

    return (
      <div {...classes()}>
        {this.getMainAsset()}
        <p itemProp='description' {...classes('intro', null, 'type-intro')}>{this.props.teaser}</p>
        <div itemProp="articleBody" {...classes('body', null)}>
          {this.getEnrichments()}
        </div>
        <Tags items={this.props.keywords} />
      </div>
    );
  }

});
