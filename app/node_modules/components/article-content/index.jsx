import React from 'react';
import bem from 'react-bem-helper';

import MainAsset from 'components/main-asset';
import Intro from 'components/intro';
import ArticleBody from 'components/article-body';
import Tags from 'components/tags';

const classes = new bem({
  name: 'article-content',
  prefix: ''
});

export default React.createClass({

  displayName: 'ArticleContent',

  propTypes: {
    mainAsset: React.PropTypes.object,
    enrichments: React.PropTypes.array,
    intro: React.PropTypes.string,
    text: React.PropTypes.string.isRequired,
    tags: React.PropTypes.array
  },

  getEnrichmentComponent(kind) {
    var kinds = {
      'text_stoerer': EnrichmentText,
      'image_stoerer': EnrichmentImage,
      'download_stoerer': EnrichmentDownload,
      // This is meant for the main asset which is not an interferer in itself
      // and has its own `content_type`. Still, we want it to behave the same
      // way as any other st√∂rer.
      'asset_image': EnrichmentImage
    };

    if (typeof kinds[kind] === 'undefined') {
      return false;
    }

    return kinds[kind];
  },

  isCuratedToken(index, text) {
    var token = '<p>${{curated}}</p>';
    return text.slice(index, index + token.length) === token;
  },

  enrichContent() {
    var chunks = [];
    var text = this.props.text.replace(/<p>(\s|&nbsp;)*<\/p>/g, '');
    var token = /<p>\${{(stoerer|curated)}}<\/p>/;
    var curated = false;
    var interfererIndex = 0;
    var rawIndex = 0;
    var index = text.search(token);

    // While there are tokens in the content and we still have interferers left
    // to display, keep going
    while (index > -1 && interfererIndex < this.props.stoerer.length) {
      // Unless the token is at the very beginning, push the content before the
      // token in the `chunks` array
      if (index > 0) {
        chunks.push(
          <RawContent key={'raw' + rawIndex} content={text.slice(0, index)} />
        );
        rawIndex += 1;
      }

      // If the curated section has not been spotted yet and we deal with the
      // token for the curated section, push the curated recommendations
      // component in the `chunks` array and put curated to true
      if (!curated && this.isCuratedToken(index, text)) {
        chunks.push(<CuratedRecommendations author={this.props.author} {...{ teasers: this.props.curated}} />);
        curated = true;
      } else {
        var interferer = this.props.stoerer[interfererIndex];
        var Component = this.getEnrichmentComponent(interferer.stoerer_type);

        if (Component) {
          var Node = <Component key={'interferer' + interfererIndex} {...interferer} />;
          chunks.push(
            interferer.placement && ['left', 'right'].indexOf(interferer.placement) > -1
              ? <Aside>{Node}</Aside>
              : Node
          );
        }

        interfererIndex += 1;
      }

      text = text.slice(index + token.length);
      index = text.search(token);
    }

    // Deal with the end of content
    if (text.length > 0) {
      // Get rid of any extra token
      text = text.replace('<p>${{stoerer}}</p>', '');
      // Push the last portion of text to `chunks` array
      chunks.push(<RawContent key='rawLast' content={text} />);
    }

    return chunks;
  },

  getMainAsset() {
    if (this.props.assets.length > 0) {
      return React.createElement(
        this.getEnrichmentComponent(this.props.assets[0].asset.content_type),
        this.props.assets[0]
      );
    }

    return undefined;
  },

  render() {
    return (
      <div {...classes()}>
        {this.props.enrichments ? <MainAsset asset={this.props.mainAsset} /> : ''}
        {this.props.intro ? <Intro text={this.props.intro} /> : ''}
        <ArticleBody text={this.props.text} enrichments={this.props.enrichments} />
        {this.props.tags ? <Tags items={this.props.tags} /> : ''}
      </div>
    );
  }

});
