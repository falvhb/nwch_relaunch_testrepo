import _ from 'lodash';
import getViewportWidth from 'helpers/viewport/get-width';

export default class StickyNode {

  constructor(options) {
    Object.keys(options).forEach((key) => {
      this[key] = options[key];
    });

    this.$element = document.querySelector(this.element);
    this.$parent = document.querySelector(this.parent);
    this.$rename = document.querySelector(this.parent);
    this.$container = document.querySelector(this.container) || this.$parent.parentNode;
  }

  getPosition(element) {
    let e = element;
    let xPosition = 0;
    let yPosition = 0;

    do {
      xPosition += (e.offsetLeft - e.scrollLeft + e.clientLeft);
      yPosition += (e.offsetTop - e.scrollTop + e.clientTop);
      e = e.offsetParent;
      // Firefox bug:
      // http://stackoverflow.com/questions/28633221/document-body-scrolltop-firefox-returns-0-only-js
      if (e === document.body && navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
        e = document.documentElement;
      }
    } while (e);

    return { x: xPosition, y: yPosition };
  }

  scrollBehaviour() {

    let yPosition = this.getPosition(this.$parent).y;
    let stopY = this.getPosition(this.$container).y + this.$container.clientHeight - this.$parent.offsetHeight;
    let y = 0;

    if (stopY - this.offset <= 0) {
      y = stopY;
    } else if (yPosition - this.offset <= 0) {
      y = this.offset;
    }

    this.fixedPosition(y);

  }

  fixedPosition(y) {
    this.$element.style.position = y ? 'fixed' :  'static';
    this.$element.style.top = y ? y + 'px' : 'auto';
  }

  toggleStickyScrolling() {

    let breakpoint = this.breakpoint || 0;
    this.scrollBehaviour = _.throttle(this.scrollBehaviour.bind(this), 10);

    if (getViewportWidth() > breakpoint && this.enoughHeight()) {
      window.addEventListener('scroll', this.scrollBehaviour);
      this.scrollBehaviour();
    } else {
      window.removeEventListener('scroll', this.scrollBehaviour);
    }

    this.repositionVertically();
  }

  hasElements() {
    return this.$element && this.$parent && this.$container;
  }

  enoughHeight() {
    return this.$container.offsetHeight > this.height;
  }

  init() {
    if (this.hasElements()) {
      // set events and init
      let debounced = _.debounce(this.toggleStickyScrolling.bind(this), 200);
      window.addEventListener('resize', debounced, false);
      this.toggleStickyScrolling();
    } else {
      console.warn('Please define element, parent and container (id="sticky-wrapper") for sticky node'); // eslint-disable-line no-console
    }
  }

  repositionVertically() {
    let parentContainer = this.$parent.parentNode;
    let verticalDifference = this.getPosition(this.$container).y - this.getPosition(parentContainer).y;
    if (verticalDifference !== 0) {
      this.$parent.style.top = verticalDifference + 'px';
    }
  }

  update() {
    this.scrollBehaviour();
  }

}
